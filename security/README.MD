# Implementing RBAC

1. Open a shell in your host machine and navigate to the root directory of this repository from where you ssh to the master node previously. You should be in the `k8s-labs-mnemon` directory. From this directory issue the following commands to get the names of the booted nodes

```bash
PS C:\Users\shoun\OneDrive\Documents\kubernetes\k8s-labs-mnemon> vagrant status
Current machine states:

master                    running (virtualbox)
node01                    running (virtualbox)
node02                    running (virtualbox)

This environment represents multiple VMs. The VMs are all listed
above with their current state. For more information about a specific
VM, run `vagrant status NAME`.
PS C:\Users\shoun\OneDrive\Documents\kubernetes\k8s-labs-mnemon>
```

As we can see we have a 3 node cluster. 1 master and 2 worker nodes

2. Now from this shell ssh to the master node:

```bash
PS C:\Users\shoun\OneDrive\Documents\kubernetes\k8s-labs-mnemon> vagrant ssh master
Welcome to Ubuntu 22.04.2 LTS (GNU/Linux 5.15.0-67-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu Oct 12 03:49:22 PM UTC 2023

  System load:  1.01416015625      Users logged in:        0
  Usage of /:   19.5% of 30.34GB   IPv4 address for eth0:  10.0.2.15
  Memory usage: 23%                IPv4 address for eth1:  192.168.56.20
  Swap usage:   0%                 IPv4 address for tunl0: 172.16.77.128
  Processes:    182

 * Introducing Expanded Security Maintenance for Applications.
   Receive updates to over 25,000 software packages with your
   Ubuntu Pro subscription. Free for personal use.

     https://ubuntu.com/pro


This system is built by the Bento project by Chef Software
More information can be found at https://github.com/chef/bento
Last login: Thu Oct 12 12:42:29 2023 from 10.0.2.2
vagrant@master-node:~$
```

3. Most new clusters will start you with a fully privileged user account that can perform any Kubernetes action. RBAC is an optional feature that can be turned off altogether. Run the following command to see if it’s enabled:

```bash
vagrant@master-node:~$ kubectl api-versions | grep rbac.authorization.k8s
rbac.authorization.k8s.io/v1
vagrant@master-node:~$
```

4. Create a Test User

Next, you’ll create a test user account that you’ll assign your RBAC roles to. Kubernetes recognizes two types of user: a normal user and a service account. Normal users can’t be added using regular API calls, so we’ll create a service account for this lab.

Run the following command to add a new service account called `demo`:

```bash
vagrant@master-node:~$ kubectl create serviceaccount demo
serviceaccount/demo created
vagrant@master-node:~$
```

5. Beginning K8s 1.22 and later, service accounts are not given a token by default as can be seen from the output below:

```bash
vagrant@master-node:~$ kubectl describe serviceaccount demo
Name:                demo
Namespace:           default
Labels:              <none>
Annotations:         <none>
Image pull secrets:  <none>
Mountable secrets:   <none>
Tokens:              <none>
Events:              <none>
vagrant@master-node:~$
```

Hence we have to manually create a Long-Lived Token for the ServiceAccount. Now navigate to the folder `/vagrant/security` and look at the file secret-demo-sa.yaml

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: demo-secret
  annotations:
    kubernetes.io/service-account.name: demo
type: kubernetes.io/service-account-token
```

Create the secret by issuing the following command and check if it is created successfully:

```bash
vagrant@master-node:/vagrant/security$ kubectl create -f secret-demo-sa.yaml
secret/build-robot-secret created
vagrant@master-node:/vagrant/security$ kubectl get secrets
NAME          TYPE                                  DATA   AGE
demo-secret   kubernetes.io/service-account-token   3      118s
vagrant@master-node:/vagrant/security$ 
```

6. Look at the token generated by issuing the following command:

```bash
vagrant@master-node:/vagrant/security$ TOKEN=$(kubectl describe secret demo-secret | grep token: | awk '{print $2}')
vagrant@master-node:/vagrant/security$ echo $TOKEN
eyJhbGci....
vagrant@master-node:/vagrant/security$
```
The TOKEN value has been hidden for security purposes

7. With the token extracted, you can add your user as a new kubectl context:

First look at the kubernetes config for your kubeconfig and check the name of the cluster

```bash
vagrant@master-node:/vagrant/security$ kubectl config view
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://192.168.56.20:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: kubernetes-admin
  name: kubernetes-admin@kubernetes
current-context: kubernetes-admin@kubernetes
kind: Config
preferences: {}
users:
- name: kubernetes-admin
  user:
    client-certificate-data: DATA+OMITTED
    client-key-data: DATA+OMITTED
vagrant@master-node:/vagrant/security$
```

In this case the cluster name is kubernetes and the default context name is `kubernetes-admin@kubernetes`. Let's create one more context from the TOKEN for the service account created above:

```bash
vagrant@master-node:/vagrant/security$ kubectl config set-credentials demo --token=$TOKEN
User "demo" set.
vagrant@master-node:/vagrant/security$ kubectl config set-context demo --cluster=kubernetes --user=demo
Context "demo" created.
vagrant@master-node:/vagrant/security$
```
If we view the config again, we see that we have two contexts now. 

```bash
vagrant@master-node:/vagrant/security$ kubectl config view
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://192.168.56.20:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: demo
  name: demo
- context:
    cluster: kubernetes
    user: kubernetes-admin
  name: kubernetes-admin@kubernetes
current-context: kubernetes-admin@kubernetes
kind: Config
preferences: {}
users:
- name: demo
  user:
    token: REDACTED
- name: kubernetes-admin
  user:
    client-certificate-data: DATA+OMITTED
    client-key-data: DATA+OMITTED
vagrant@master-node:/vagrant/security$
```

8. Check the current context and set the context to the demo user:

```bash
vagrant@master-node:/vagrant/security$ kubectl config current-context
kubernetes-admin@kubernetes
vagrant@master-node:/vagrant/security$ kubectl config use-context demo
Switched to context "demo".
vagrant@master-node:/vagrant/security$
```

Now if you try to get pods with the demo user, you should get an error:

```bash
vagrant@master-node:/vagrant/security$ kubectl get pods
Error from server (Forbidden): pods is forbidden: User "system:serviceaccount:default:demo" cannot list resource "pods" in API group "" in the namespace "default"
vagrant@master-node:/vagrant/security$
```

9. Switch back to the admin context:

```bash
vagrant@master-node:/vagrant/security$ kubectl config use-context kubernetes-admin@kubernetes
Switched to context "kubernetes-admin@kubernetes".
vagrant@master-node:/vagrant/security$
```

10. Let's now create a Role and RoleBinding to allow the demo user to do some operations on Pods.

Consider the file role-demo.yaml

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: Developer
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["create", "get", "list"]
```
This role lets the user get, list and create pods.

Create the Role:

```bash
vagrant@master-node:/vagrant/security$ kubectl create -f role-demo.yaml
role.rbac.authorization.k8s.io/Developer created
vagrant@master-node:/vagrant/security$
```

Now consider the RoleBinding file rb-demo.yaml

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  namespace: default
  name: DeveloperRoleBinding
subjects:
  - kind: ServiceAccount
    name: demo
    apiGroup: ""
roleRef:
  kind: Role
  name: Developer
  apiGroup: ""
```

Create the Role Binding file:

```bash
vagrant@master-node:/vagrant/security$ kubectl create -f rb-demo.yaml
rolebinding.rbac.authorization.k8s.io/DeveloperRoleBinding created
vagrant@master-node:/vagrant/security$
```

11. Switch to the demo context again:

```bash
vagrant@master-node:/vagrant/security$ kubectl config use-context demo
Switched to context "demo".
vagrant@master-node:/vagrant/security$
```

12. Try to list pods 

```bash
vagrant@master-node:/vagrant/security$ kubectl get pods
No resources found in default namespace.
vagrant@master-node:/vagrant/security$
```

Now we have the permission to list the Pods

13. Create a new Pod:

```bash
vagrant@master-node:/vagrant/security$ kubectl run demo-nginx --image=nginx
pod/demo-nginx created
vagrant@master-node:/vagrant/security$
```
and check if it is running:

```bash
vagrant@master-node:/vagrant/security$ kubectl get po
NAME         READY   STATUS    RESTARTS   AGE
demo-nginx   1/1     Running   0          118s
vagrant@master-node:/vagrant/security$
```

14. Now try to delete the Pod:

```bash
vagrant@master-node:/vagrant/security$ kubectl delete po demo-nginx
Error from server (Forbidden): pods "demo-nginx" is forbidden: User "system:serviceaccount:default:demo" cannot delete resource "pods" in API group "" in the namespace "default"
vagrant@master-node:/vagrant/security$
```

As you can see we were not allowed to delete the Pod as the Role only had get, list and create permissions

## Clean Up

Switch back to the admin context and delete the Pod

```bash
vagrant@master-node:/vagrant/security$ kubectl config use-context kubernetes-admin@kubernetes
Switched to context "kubernetes-admin@kubernetes".
vagrant@master-node:/vagrant/security$ kubectl delete po demo-nginx
pod "demo-nginx" deleted
vagrant@master-node:/vagrant/autoscaling$ kubectl delete secret demo-secret
secret "demo-secret" deleted
vagrant@master-node:/vagrant/autoscaling$
```